# sweetness_score.py

def calculate_sweetness_score(
    revenue_generated,
    retention_lift,
    delayed_bloom_bonus=False
):
    """
    Computes the scroll's sweetness index. The index is a composite score based
    on revenue, retention lift, and a delayed bloom bonus. The formula is:
        sweetness_index = (revenue_score * 0.3) + (retention_lift * 0.5) +
                          (delay_score * 0.2)
    where:
        revenue_score = min(revenue_generated / 25000.0, 1.0)
        retention_lift = retention lift (e.g., 0.23 for 23%)
        delay_score = 1.0 if delayed_bloom_bonus else 0.0
    The final index is a weighted sum of these components, with the following
    weights:
        - Revenue: 30%
        - Retention: 50%
        - Delay Bonus: 20%
    The index is capped at 1.0 for revenue and is rounded to three decimal
    places. The delay score is rounded to two decimal places. The function
    returns a dictionary with the following keys:
        - revenue_score: Normalized revenue score (0.0 to 1.0)
        - retention_lift: Retention lift value
        - delay_score: Delay bonus score (0.0 or 1.0)
        - sweetness_index: Final sweetness index (0.0 to 1.0)
    The function is designed to be used in the context of evaluating the
    performance of a scroll in a gaming or simulation environment, where
    revenue and retention metrics are important indicators of success. It is
    assumed that the revenue generated is in USD and that the retention lift
    is a decimal value representing the percentage increase in user retention.
    The function also includes an optional parameter for a delayed bloom bonus,
    which is a boolean indicating whether the scroll bloomed after a delay or
    failure. This bonus is factored into the final sweetness index calculation.
    The function is designed to be flexible and can be easily modified to
    include additional parameters or change the weights of the components if
    needed in the future. The function is also designed to be efficient, with
    a focus on clarity and maintainability. The revenue score is calculated by
    dividing the revenue generated by a cap of 25,000, ensuring that the score
    does not exceed 1.0. The retention lift is assumed to be a decimal value
    representing the percentage increase in user retention. The delay score is
    a simple binary value, either 0.0 or 1.0, based on the delayed bloom bonus
    parameter.
    Args:
        revenue_generated (float): In USD.
        retention_lift (float): e.g., 0.23 for 23%.
        delayed_bloom_bonus (bool): True if scroll bloomed after delay/failure.
    Returns:
        dict: Score components and final index.
    """

    # Normalize revenue (assume cap at 25,000 for now)
    revenue_score = min(revenue_generated / 25000.0, 1.0)

    # Score components
    weights = {
        "revenue": 0.3,
        "retention": 0.5,
        "delay_bonus": 0.2
    }

    delay_score = 1.0 if delayed_bloom_bonus else 0.0

    sweetness_index = (
        revenue_score * weights["revenue"] +
        retention_lift * weights["retention"] +
        delay_score * weights["delay_bonus"]
    )

    return {
        "revenue_score": round(revenue_score, 3),
        "retention_lift": round(retention_lift, 3),
        "delay_score": round(delay_score, 2),
        "sweetness_index": round(sweetness_index, 3)
    }